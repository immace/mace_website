<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Glass M — Shake me to let it snow</title>
  <style>
    html, body { margin:0; height:100%; background:#07080a; overflow:hidden; }
    #app { position:fixed; inset:0; }

    /* Bottom caption */
    .caption {
      position: fixed;
      left: 0; right: 0;
      bottom: 18px;
      z-index: 10;
      pointer-events: none;
      display: flex;
      justify-content: center;
      padding: 0 16px;
      font: 15px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      letter-spacing: -0.01em;
      color: rgba(255,255,255,.86);
      text-shadow: 0 14px 60px rgba(0,0,0,.75);
    }
    .caption span{
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(14px);
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="caption"><span>Shake me to let it snow…</span></div>
  <div id="app"></div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

const container = document.getElementById("app");
const scene = new THREE.Scene();

// Camera
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 60);
camera.position.set(0, 0.05, 3.2);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.28;
container.appendChild(renderer.domElement);

// Desktop orbit (optional). You can disable entirely if you want.
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.rotateSpeed = 0.55;
controls.minDistance = 2.0;
controls.maxDistance = 5.0;
controls.enablePan = false;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.18));
const key = new THREE.DirectionalLight(0xffffff, 1.35);
key.position.set(2.8, 3.4, 2.2);
scene.add(key);

const rim = new THREE.DirectionalLight(0xffffff, 0.65);
rim.position.set(-3.2, 0.8, -1.4);
scene.add(rim);

// Premium reflections
new RGBELoader()
  .setPath("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/")
  .load("royal_esplanade_1k.hdr", (tex) => {
    tex.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = tex;
  });

// Root
const root = new THREE.Group();
scene.add(root);

const letter = new THREE.Group();
root.add(letter);

// Rest pose (will spring back here)
const restPos = new THREE.Vector3(0, -0.10, 0);
const restRot = new THREE.Euler(0, 0, 0);
letter.position.copy(restPos);
letter.rotation.copy(restRot);

// ----- MATERIALS: more "volumetric / rounded / premium" -----
const glassMat = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color("#ffffff"),
  metalness: 0.0,
  roughness: 0.035,
  transmission: 1.0,
  thickness: 1.15,     // makes it feel deeper
  ior: 1.58,
  reflectivity: 0.75,
  clearcoat: 1.0,
  clearcoatRoughness: 0.03,
  envMapIntensity: 1.5
});

// Slight internal tint to avoid "flat red plastic"
const innerMat = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color("#b10f1d"),
  metalness: 0.28,
  roughness: 0.12,
  transmission: 0.22,
  thickness: 0.65,
  ior: 1.38,
  reflectivity: 0.55,
  envMapIntensity: 1.1
});

// If your SVG is flipped, toggle this
const SVG_FLIP_Y = true;

// Fit letter to view (no giant SVG)
function fitLetterToView(targetHeight = 1.45) {
  const b = new THREE.Box3().setFromObject(letter);
  const s = new THREE.Vector3();
  b.getSize(s);
  if (s.y <= 0) return;

  const k = targetHeight / s.y;
  letter.scale.setScalar(k);

  b.setFromObject(letter);
  const c = new THREE.Vector3();
  b.getCenter(c);
  letter.position.copy(restPos).sub(c);
}

// Load SVG -> Extrude (MAKE IT REALLY ROUNDED & THICK)
async function loadLetter() {
  const loader = new SVGLoader();
  const svgData = await new Promise((resolve, reject) => {
    loader.load("assets/m.svg", resolve, undefined, reject);
  });

  const shapes = [];
  for (const p of svgData.paths) {
    const ss = SVGLoader.createShapes(p);
    for (const s of ss) shapes.push(s);
  }

  // Much more "volumetric" than before:
  const geom = new THREE.ExtrudeGeometry(shapes, {
    depth: 1.10,            // thick volume (was small)
    bevelEnabled: true,
    bevelThickness: 0.30,   // roundness
    bevelSize: 0.22,        // roundness
    bevelSegments: 24,      // smooth
    curveSegments: 64
  });

  geom.center();
  if (SVG_FLIP_Y) {
    geom.scale(1, -1, 1);
    geom.center();
  }
  geom.computeVertexNormals();

  const outer = new THREE.Mesh(geom, glassMat);

  // Inner "core" slightly smaller to create depth + embedded color
  const innerGeom = geom.clone();
  innerGeom.scale(0.965, 0.965, 0.88);
  innerGeom.center();
  const inner = new THREE.Mesh(innerGeom, innerMat);

  letter.add(outer, inner);

  const isPortrait = innerHeight >= innerWidth;
  fitLetterToView(isPortrait ? 1.55 : 1.25);
}
await loadLetter();

// ---------------- SNOW (ONLY WHEN SHAKING) ----------------
const SNOW_COUNT = 2400;
const snowGeo = new THREE.SphereGeometry(0.010, 10, 10);
const snowMat = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  roughness: 0.35,
  metalness: 0.0
});

const snow = new THREE.InstancedMesh(snowGeo, snowMat, SNOW_COUNT);
snow.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
letter.add(snow);

const pos = Array.from({ length: SNOW_COUNT }, () => new THREE.Vector3());
const vel = Array.from({ length: SNOW_COUNT }, () => new THREE.Vector3());

const tmpM = new THREE.Matrix4();
const tmpP = new THREE.Vector3();
const tmpQ = new THREE.Quaternion();
const tmpS = new THREE.Vector3(1,1,1);

const box = new THREE.Box3();

function reseedSnow() {
  box.setFromObject(letter);
  const pad = 0.14;
  const min = box.min.clone().addScalar(pad);
  const max = box.max.clone().addScalar(-pad);

  for (let i=0; i<SNOW_COUNT; i++) {
    pos[i].set(
      THREE.MathUtils.lerp(min.x, max.x, Math.random()),
      THREE.MathUtils.lerp(min.y, max.y, Math.random()),
      THREE.MathUtils.lerp(min.z, max.z, Math.random())
    );
    vel[i].set(0, 0, 0);
  }
}
reseedSnow();

function gravityFromLetter() {
  const q = letter.getWorldQuaternion(new THREE.Quaternion());
  return new THREE.Vector3(0, -1, 0).applyQuaternion(q).normalize();
}

// Snow intensity: 0 (off) -> 1 (on)
let snowIntensity = 0;
let snowTarget = 0;

// ---------------- Interaction: grab & shake ----------------
let isGrabbed = false;
let grabPointerId = null;
const raycaster = new THREE.Raycaster();
const ndc = new THREE.Vector2();

let lastPointer = { x: 0, y: 0, t: performance.now() };

function setNDCFromEvent(e) {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
  const y = - ( (e.clientY - rect.top) / rect.height ) * 2 + 1;
  ndc.set(x, y);
}

function hitTestLetter(e) {
  setNDCFromEvent(e);
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObjects(letter.children, true);
  return hits.length > 0;
}

// Burst helper (adds random impulses so snow visibly moves)
function burst(power = 0.22, count = 900) {
  box.setFromObject(letter);
  const pad = 0.14;
  const min = box.min.clone().addScalar(pad);
  const max = box.max.clone().addScalar(-pad);

  for (let k=0; k<count; k++) {
    const i = (Math.random() * SNOW_COUNT) | 0;
    // re-seed some particles during burst for stronger effect
    if (Math.random() < 0.15) {
      pos[i].set(
        THREE.MathUtils.lerp(min.x, max.x, Math.random()),
        THREE.MathUtils.lerp(min.y, max.y, Math.random()),
        THREE.MathUtils.lerp(min.z, max.z, Math.random())
      );
    }
    vel[i].addScaledVector(
      new THREE.Vector3((Math.random()-0.5), (Math.random()-0.15), (Math.random()-0.5)),
      power
    );
  }
}

renderer.domElement.addEventListener("pointerdown", (e) => {
  if (!hitTestLetter(e)) return;

  isGrabbed = true;
  grabPointerId = e.pointerId;
  renderer.domElement.setPointerCapture(grabPointerId);

  controls.enabled = false;
  lastPointer = { x: e.clientX, y: e.clientY, t: performance.now() };

  // Turn snow on when grabbed (but it will only "move hard" on shake)
  snowTarget = 1;
}, { passive: true });

renderer.domElement.addEventListener("pointermove", (e) => {
  if (!isGrabbed || e.pointerId !== grabPointerId) return;

  const now = performance.now();
  const dt = Math.max(1, now - lastPointer.t);
  const dx = e.clientX - lastPointer.x;
  const dy = e.clientY - lastPointer.y;

  // Rotate as if you hold the letter
  const rotSpeed = 0.006;
  letter.rotation.y += dx * rotSpeed;
  letter.rotation.x += dy * rotSpeed;
  letter.rotation.x = THREE.MathUtils.clamp(letter.rotation.x, -0.95, 0.95);

  // Shake detection: pointer speed
  const speed = Math.sqrt(dx*dx + dy*dy) / dt; // px/ms
  if (speed > 0.45) {
    // Strong shake -> visible snow burst
    burst(0.18 + Math.min(0.22, (speed-0.45)*0.25), 1100);
  } else if (speed > 0.22) {
    // Gentle shake -> small movement
    burst(0.10, 450);
  }

  lastPointer = { x: e.clientX, y: e.clientY, t: now };
}, { passive: true });

function releaseGrab(e) {
  if (!isGrabbed) return;
  isGrabbed = false;
  grabPointerId = null;
  controls.enabled = true;

  // Let snow fade out after release
  snowTarget = 0;
}

renderer.domElement.addEventListener("pointerup", (e) => {
  if (e.pointerId !== grabPointerId) return;
  try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
  releaseGrab(e);
}, { passive: true });

renderer.domElement.addEventListener("pointercancel", (e) => {
  if (e.pointerId !== grabPointerId) return;
  releaseGrab(e);
}, { passive: true });

// ------------- Smooth spring-back to rest pose -------------
const clock = new THREE.Clock();
const spring = {
  posK: 14.0,
  rotK: 12.0,
  damping: 0.84,
  velPos: new THREE.Vector3(),
  velRot: new THREE.Vector3()
};

function springReturn(dt) {
  if (isGrabbed) return;

  // Position
  const posErr = restPos.clone().sub(letter.position);
  spring.velPos.addScaledVector(posErr, spring.posK * dt);
  spring.velPos.multiplyScalar(Math.pow(spring.damping, dt * 60));
  letter.position.addScaledVector(spring.velPos, dt);

  // Rotation
  const rotErr = new THREE.Vector3(
    restRot.x - letter.rotation.x,
    restRot.y - letter.rotation.y,
    restRot.z - letter.rotation.z
  );
  spring.velRot.addScaledVector(rotErr, spring.rotK * dt);
  spring.velRot.multiplyScalar(Math.pow(spring.damping, dt * 60));
  letter.rotation.x += spring.velRot.x * dt;
  letter.rotation.y += spring.velRot.y * dt;
  letter.rotation.z += spring.velRot.z * dt;

  // Snap when close
  if (posErr.length() < 0.0008 && rotErr.length() < 0.0008) {
    letter.position.copy(restPos);
    letter.rotation.copy(restRot);
    spring.velPos.set(0,0,0);
    spring.velRot.set(0,0,0);
  }
}

// ------------- Snow simulation -------------
const damping = 0.986;
const gravityStrength = 0.85;
const bounce = 0.40;

function updateSnow(dt) {
  // smooth intensity towards target
  const lerp = 1 - Math.pow(0.001, dt);
  snowIntensity = THREE.MathUtils.lerp(snowIntensity, snowTarget, lerp);

  // Scale particles down to zero when snow is off (true "off")
  const snowScale = snowIntensity * 1.0; // you can push 1.2 if you want

  box.setFromObject(letter);
  const pad = 0.14;
  const min = box.min.clone().addScalar(pad);
  const max = box.max.clone().addScalar(-pad);

  const g = gravityFromLetter();

  for (let i=0; i<SNOW_COUNT; i++) {
    // basic physics
    vel[i].addScaledVector(g, gravityStrength * dt);
    vel[i].multiplyScalar(damping);
    pos[i].addScaledVector(vel[i], dt);

    // collisions in volume (approx)
    if (pos[i].x < min.x) { pos[i].x = min.x; vel[i].x *= -bounce; }
    if (pos[i].x > max.x) { pos[i].x = max.x; vel[i].x *= -bounce; }
    if (pos[i].y < min.y) { pos[i].y = min.y; vel[i].y *= -bounce; }
    if (pos[i].y > max.y) { pos[i].y = max.y; vel[i].y *= -bounce; }
    if (pos[i].z < min.z) { pos[i].z = min.z; vel[i].z *= -bounce; }
    if (pos[i].z > max.z) { pos[i].z = max.z; vel[i].z *= -bounce; }

    // write instance matrix with scale = snowScale (0 => invisible)
    tmpP.copy(pos[i]);
    tmpS.set(snowScale, snowScale, snowScale);
    tmpM.compose(tmpP, tmpQ, tmpS);
    snow.setMatrixAt(i, tmpM);
  }

  snow.instanceMatrix.needsUpdate = true;
}

// Resize
function onResize() {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);

  const isPortrait = innerHeight >= innerWidth;
  fitLetterToView(isPortrait ? 1.55 : 1.25);
  reseedSnow();
}
addEventListener("resize", onResize, { passive:true });

// Loop
function tick() {
  const dt = Math.min(clock.getDelta(), 0.033);

  controls.update();
  springReturn(dt);
  updateSnow(dt);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();
</script>
</body>
</html>
