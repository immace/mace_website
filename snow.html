<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Glass M + Snow (Mobile Shake + Desktop Rotate)</title>
  <style>
    html, body { margin:0; height:100%; background:#07080a; overflow:hidden; }
    #app { position:fixed; inset:0; }
    .ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      display:flex; gap:10px; align-items:center;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.92);
      user-select:none;
    }
    .btn {
      padding: 10px 12px; border-radius: 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      color: #fff; cursor:pointer;
      backdrop-filter: blur(10px);
    }
    .hint { opacity:.75; max-width: 66vw; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="ui">
    <button id="motionBtn" class="btn">Enable motion</button>
    <div class="hint">Drag to rotate (desktop). Tilt / shake (phone) to move snow.</div>
  </div>
  <div id="app"></div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

const container = document.getElementById("app");
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 50);
camera.position.set(0, 0.15, 2.6);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
container.appendChild(renderer.domElement);

// Controls (desktop)
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.rotateSpeed = 0.6;
controls.minDistance = 1.6;
controls.maxDistance = 4.0;
controls.enablePan = false;

// Lighting / environment
scene.add(new THREE.AmbientLight(0xffffff, 0.22));
const key = new THREE.DirectionalLight(0xffffff, 1.15);
key.position.set(2, 3, 2);
scene.add(key);

// Environment HDR for premium glass reflections
new RGBELoader()
  .setPath("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/")
  .load("royal_esplanade_1k.hdr", (tex) => {
    tex.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = tex;
  });

// Group for letter
const group = new THREE.Group();
scene.add(group);

// Glass material (liquid-glass vibe)
const glassMat = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color("#ffffff"),
  metalness: 0.0,
  roughness: 0.055,
  transmission: 1.0,
  thickness: 0.36,
  ior: 1.52,
  reflectivity: 0.62,
  clearcoat: 1.0,
  clearcoatRoughness: 0.06,
  envMapIntensity: 1.25
});

// Inner tint (subtle embedded color)
const innerMat = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color("#b10f1d"),
  metalness: 0.16,
  roughness: 0.18,
  transmission: 0.32,
  thickness: 0.22,
  ior: 1.35,
  reflectivity: 0.35,
  envMapIntensity: 0.95
});

// Helper: fit letter to view (prevents "giant SVG" problem)
function fitLetterToView(targetHeight = 1.2) {
  const b = new THREE.Box3().setFromObject(group);
  const s = new THREE.Vector3();
  b.getSize(s);

  if (s.y <= 0) return;

  // normalize scale by height
  const k = targetHeight / s.y;
  group.scale.multiplyScalar(k);

  // center in world
  b.setFromObject(group);
  const c = new THREE.Vector3();
  b.getCenter(c);
  group.position.sub(c);

  // tiny aesthetic offset
  group.position.y -= 0.05;
}

// Load SVG and extrude to 3D
async function loadLetter() {
  const loader = new SVGLoader();
  const svgData = await new Promise((resolve, reject) => {
    // Put your SVG here: /assets/m.svg
    loader.load("assets/m.svg", resolve, undefined, reject);
  });

  const shapes = [];
  for (const p of svgData.paths) {
    const toShapes = SVGLoader.createShapes(p);
    for (const s of toShapes) shapes.push(s);
  }

  const extrude = new THREE.ExtrudeGeometry(shapes, {
    depth: 0.35,
    bevelEnabled: true,
    bevelThickness: 0.08,
    bevelSize: 0.05,
    bevelSegments: 8,
    curveSegments: 32
  });
  extrude.computeVertexNormals();
  extrude.center();

  const glassMesh = new THREE.Mesh(extrude, glassMat);

  // Inner volume (slightly smaller)
  const innerGeo = extrude.clone();
  innerGeo.scale(0.96, 0.96, 0.85);
  innerGeo.center();
  const innerMesh = new THREE.Mesh(innerGeo, innerMat);

  group.add(glassMesh, innerMesh);

  // IMPORTANT: normalize size so SVG won't be huge
  // For vertical screens we want a bit taller hero object
  const isPortrait = innerHeight >= innerWidth;
  fitLetterToView(isPortrait ? 1.25 : 1.0);
}

await loadLetter();

// --- Snow particles (simple physics inside bounding box approximation) ---
const SNOW_COUNT = 1800;

const snowGeo = new THREE.SphereGeometry(0.008, 8, 8);
const snowMat = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  roughness: 0.35,
  metalness: 0.0
});

const snow = new THREE.InstancedMesh(snowGeo, snowMat, SNOW_COUNT);
snow.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
group.add(snow);

// Particle state
const positions = Array.from({ length: SNOW_COUNT }, () => new THREE.Vector3());
const velocity  = Array.from({ length: SNOW_COUNT }, () => new THREE.Vector3());

const tmpM = new THREE.Matrix4();
const tmpP = new THREE.Vector3();
const tmpQ = new THREE.Quaternion();
const tmpS = new THREE.Vector3(1,1,1);

const box = new THREE.Box3();
const size = new THREE.Vector3();

function seedSnow() {
  box.setFromObject(group);
  box.getSize(size);

  // pad keeps particles inside
  const pad = 0.08;
  const min = box.min.clone().addScalar(pad);
  const max = box.max.clone().addScalar(-pad);

  for (let i=0; i<SNOW_COUNT; i++) {
    positions[i].set(
      THREE.MathUtils.lerp(min.x, max.x, Math.random()),
      THREE.MathUtils.lerp(min.y, max.y, Math.random()),
      THREE.MathUtils.lerp(min.z, max.z, Math.random())
    );
    velocity[i].set(
      (Math.random()-0.5)*0.02,
      (Math.random()-0.5)*0.02,
      (Math.random()-0.5)*0.02
    );
  }
}
seedSnow();

// Gravity vector: device tilt OR group rotation
let deviceGravity = new THREE.Vector3(0, -1, 0);
let haveDeviceMotion = false;

// iOS permission button
const motionBtn = document.getElementById("motionBtn");
motionBtn.addEventListener("click", async () => {
  try {
    if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
      const res = await DeviceMotionEvent.requestPermission();
      if (res !== "granted") return;
    }

    window.addEventListener("deviceorientation", (e) => {
      // gamma: left/right, beta: front/back
      const beta = (e.beta ?? 0) * Math.PI/180;
      const gamma = (e.gamma ?? 0) * Math.PI/180;
      deviceGravity.set(Math.sin(gamma), -Math.cos(beta), Math.sin(beta)).normalize();
      haveDeviceMotion = true;
    }, { passive:true });

    window.addEventListener("devicemotion", (e) => {
      const a = e.accelerationIncludingGravity;
      if (!a) return;
      const mag = Math.sqrt((a.x||0)**2 + (a.y||0)**2 + (a.z||0)**2);
      if (mag > 16) {
        // shake impulse
        for (let k=0; k<80; k++) {
          const i = (Math.random()*SNOW_COUNT)|0;
          velocity[i].addScaledVector(new THREE.Vector3(
            (Math.random()-0.5), (Math.random()-0.2), (Math.random()-0.5)
          ), 0.12);
        }
      }
    }, { passive:true });

    motionBtn.textContent = "Motion enabled";
    motionBtn.style.opacity = 0.7;
  } catch (err) {
    motionBtn.textContent = "Motion not available";
    motionBtn.style.opacity = 0.7;
  }
});

// Physics params
const clock = new THREE.Clock();
const damping = 0.985;
const gravityStrength = 0.55;
const bounce = 0.45;

function gravityFromRotation() {
  const q = group.getWorldQuaternion(new THREE.Quaternion());
  const down = new THREE.Vector3(0, -1, 0).applyQuaternion(q);
  return down.normalize();
}

function updateSnow(dt) {
  box.setFromObject(group);

  const pad = 0.08;
  const min = box.min.clone().addScalar(pad);
  const max = box.max.clone().addScalar(-pad);

  const g = haveDeviceMotion ? deviceGravity : gravityFromRotation();

  for (let i=0; i<SNOW_COUNT; i++) {
    velocity[i].addScaledVector(g, gravityStrength * dt);
    velocity[i].multiplyScalar(damping);

    positions[i].addScaledVector(velocity[i], dt);

    // collide with bounding volume
    if (positions[i].x < min.x) { positions[i].x = min.x; velocity[i].x *= -bounce; }
    if (positions[i].x > max.x) { positions[i].x = max.x; velocity[i].x *= -bounce; }
    if (positions[i].y < min.y) { positions[i].y = min.y; velocity[i].y *= -bounce; }
    if (positions[i].y > max.y) { positions[i].y = max.y; velocity[i].y *= -bounce; }
    if (positions[i].z < min.z) { positions[i].z = min.z; velocity[i].z *= -bounce; }
    if (positions[i].z > max.z) { positions[i].z = max.z; velocity[i].z *= -bounce; }

    tmpP.copy(positions[i]);
    tmpM.compose(tmpP, tmpQ, tmpS);
    snow.setMatrixAt(i, tmpM);
  }
  snow.instanceMatrix.needsUpdate = true;
}

// Keep letter nicely sized on resize/orientation change
function refitOnResize() {
  // reset transform, then re-fit
  group.scale.set(1,1,1);
  group.position.set(0,0,0);

  const isPortrait = innerHeight >= innerWidth;
  fitLetterToView(isPortrait ? 1.25 : 1.0);

  // also reseed snow so it stays inside new bounds
  seedSnow();
}

addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  refitOnResize();
}, { passive:true });

// Animate
function tick() {
  const dt = Math.min(clock.getDelta(), 0.033);
  controls.update();
  updateSnow(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();
</script>
</body>
</html>
